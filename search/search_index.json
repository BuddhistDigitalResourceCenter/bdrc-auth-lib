{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BDRC Auth library \uf0c1 Documentation for the Auth library of BRDC","title":"BDRC Auth library"},{"location":"#bdrc-auth-library","text":"Documentation for the Auth library of BRDC","title":"BDRC Auth library"},{"location":"apis/","text":"The BDRC auth library uses two different auth0 APIs : The Auth0 Management API and the Auth0 authorization extension API The Auth0 Management API \uf0c1 As seen above, the Auth0 management API is used to request the Auth0 platform for tokens, for any authorized application defined in Auth0 (for instance LDSPDI or various Auth0 API extensions - BDRC uses Auth0 Management API Webhooks and Auth0 Authorization ). It is also used for decoding and validating any provided token. The Auth0 authorization extension API \uf0c1 The Auth0 authorization extension API is used to set up existing user profiles (i.e users created programmatically or through auth0 dashboard ). Auth0 authorization extension API uses the following model: Group: A group may contain users, roles or other group(s). Any user belonging to a group inherits roles of that group and is a member of all nested groups, if any (then inheriting in turn of the roles of these groups). Role : Roles are associated with permissions and always apply to a single application. Therefore, a role can only have permissions pertaining to the application it is associated with. Permission : Permissions define the finest level of authorization. They are associated with a single application. User: A user may belong to several groups, inherit all roles of these groups and all permissions of these roles. However, a user might also have specific roles that are not associated with a Group. This allows for assigning custom permissions to a specific user for specific applications.","title":"Auth0 APIs"},{"location":"apis/#the-auth0-management-api","text":"As seen above, the Auth0 management API is used to request the Auth0 platform for tokens, for any authorized application defined in Auth0 (for instance LDSPDI or various Auth0 API extensions - BDRC uses Auth0 Management API Webhooks and Auth0 Authorization ). It is also used for decoding and validating any provided token.","title":"The Auth0 Management API"},{"location":"apis/#the-auth0-authorization-extension-api","text":"The Auth0 authorization extension API is used to set up existing user profiles (i.e users created programmatically or through auth0 dashboard ). Auth0 authorization extension API uses the following model: Group: A group may contain users, roles or other group(s). Any user belonging to a group inherits roles of that group and is a member of all nested groups, if any (then inheriting in turn of the roles of these groups). Role : Roles are associated with permissions and always apply to a single application. Therefore, a role can only have permissions pertaining to the application it is associated with. Permission : Permissions define the finest level of authorization. They are associated with a single application. User: A user may belong to several groups, inherit all roles of these groups and all permissions of these roles. However, a user might also have specific roles that are not associated with a Group. This allows for assigning custom permissions to a specific user for specific applications.","title":"The Auth0 authorization extension API"},{"location":"authLib/","text":"BDRC Auth library main fonctionalities \uf0c1 Builts the RDF auth data model from auth0 and github and updates it in fuseki . The auth data model is all contained in a single named graph ( http://purl.bdrc.io/ontology/ext/authData ) Updates the ontology on fuseki whenever it changes through a github Webhook whose callback Url is http://purl.bdrc.io/callbacks/github/owl-schema endpoint on ldspdi. The Auth Ontology is a named graph ( http://purl.bdrc.io/ontology/ext/authSchema ) Keeps available and maintains an up to date RdfAuthModel java object that can be used for validating or denying the access to secured endpoints or resources. This validation mechanism is explained in the \" Using BDRC auth lib \" section of this site. Auth Model update \uf0c1 BDRC-auth library is used on various servers of the BUDA platform and each instance of it has therefore its own local RdfAuthModel object. In order to ensure the accuracy of the Auth models across all BUDA secured services, we need to synchronize these local models each time the data is modified either in Auth0 platform or BDRC policies. Since BDRC Linked data server (ldspdi) is providing all webhooks callback Urls, it is therefore in charge of building the most recent model and publishing it to fuseki. Subsequently, all models of all instances of bdrc-auth-lib must be updated. This is accomplished by each instances through a \u201ccron job\u201d implemented in io.bdrc.auth.rdf.ModelUpdate . The whole operation goes as follows: 1) A change occurs in Auth0 or in Owl-schema (ontology) or in bdrc-auth (bdrc auth policies data) 2) BDRC Linked Data server (ldspdi) is called by the relevant webhook then rebuilds the model, saves the UPDATED time and reloads the new data on Fuseki. 3) A cron job running on each instance of Bdrc-auth-lib asks ldspdi every five minutes (this period is configurable) for the UPDATED time at ( http://purl.bdrc.io/authmodel/updated ) 4) If ldspdi UPDATED time is more recent than the local UPDATED time , the local bdrc-auth-lib reloads the model from ldspdi at ( http://purl.bdrc.io/authmodel ) and updates its local UPDATED time. Note: this is not a real time update. A real time update could be done by implementing webhooks (triggerred by ldspdi) on each server instantiating bdrc-auth-lib. However, there is no valid point at that time that suggest such a real-time update implementation.","title":"BDRC Auth lib"},{"location":"authLib/#bdrc-auth-library-main-fonctionalities","text":"Builts the RDF auth data model from auth0 and github and updates it in fuseki . The auth data model is all contained in a single named graph ( http://purl.bdrc.io/ontology/ext/authData ) Updates the ontology on fuseki whenever it changes through a github Webhook whose callback Url is http://purl.bdrc.io/callbacks/github/owl-schema endpoint on ldspdi. The Auth Ontology is a named graph ( http://purl.bdrc.io/ontology/ext/authSchema ) Keeps available and maintains an up to date RdfAuthModel java object that can be used for validating or denying the access to secured endpoints or resources. This validation mechanism is explained in the \" Using BDRC auth lib \" section of this site.","title":"BDRC Auth library main fonctionalities"},{"location":"authLib/#auth-model-update","text":"BDRC-auth library is used on various servers of the BUDA platform and each instance of it has therefore its own local RdfAuthModel object. In order to ensure the accuracy of the Auth models across all BUDA secured services, we need to synchronize these local models each time the data is modified either in Auth0 platform or BDRC policies. Since BDRC Linked data server (ldspdi) is providing all webhooks callback Urls, it is therefore in charge of building the most recent model and publishing it to fuseki. Subsequently, all models of all instances of bdrc-auth-lib must be updated. This is accomplished by each instances through a \u201ccron job\u201d implemented in io.bdrc.auth.rdf.ModelUpdate . The whole operation goes as follows: 1) A change occurs in Auth0 or in Owl-schema (ontology) or in bdrc-auth (bdrc auth policies data) 2) BDRC Linked Data server (ldspdi) is called by the relevant webhook then rebuilds the model, saves the UPDATED time and reloads the new data on Fuseki. 3) A cron job running on each instance of Bdrc-auth-lib asks ldspdi every five minutes (this period is configurable) for the UPDATED time at ( http://purl.bdrc.io/authmodel/updated ) 4) If ldspdi UPDATED time is more recent than the local UPDATED time , the local bdrc-auth-lib reloads the model from ldspdi at ( http://purl.bdrc.io/authmodel ) and updates its local UPDATED time. Note: this is not a real time update. A real time update could be done by implementing webhooks (triggerred by ldspdi) on each server instantiating bdrc-auth-lib. However, there is no valid point at that time that suggest such a real-time update implementation.","title":"Auth Model update"},{"location":"build/","text":"As we might guess from previous pages, the overall auth model used by the bdrc-auth library has to be some sort of \u201cagregation\u201d of auth0 proprietary model and BDRC specific model. We therefore build the RDF auth model from two different sources ( Auth0 platform and BDRC Github repos ) as shown below: Auth0 platform data sources \uf0c1 1) Auth0 core data source \uf0c1 This source provides exclusively auth0 users basic information (username, password, email, etc...) 2) Auth0 extension data source \uf0c1 This source provides information about groups, roles, permissions associated with Auth0 users as defined by the Auth0 core platform and API. BDRC github repos data sources \uf0c1 1) BDRC Auth ontology \uf0c1 BDRC ontology defines the overall model used for implementing various security strategies within the BUDA system. 2) BDRC Auth policies \uf0c1 Auth policies specify the valid associations between Endpoint and Auth0 Groups, Roles and Applications and valid associations between ResourceAccess, BDRC AccessTypes, and Auth0 permissions .","title":"Building Rdf auth model"},{"location":"build/#auth0-platform-data-sources","text":"","title":"Auth0 platform data sources"},{"location":"build/#1-auth0-core-data-source","text":"This source provides exclusively auth0 users basic information (username, password, email, etc...)","title":"1) Auth0 core data source"},{"location":"build/#2-auth0-extension-data-source","text":"This source provides information about groups, roles, permissions associated with Auth0 users as defined by the Auth0 core platform and API.","title":"2) Auth0 extension data source"},{"location":"build/#bdrc-github-repos-data-sources","text":"","title":"BDRC github repos data sources"},{"location":"build/#1-bdrc-auth-ontology","text":"BDRC ontology defines the overall model used for implementing various security strategies within the BUDA system.","title":"1) BDRC Auth ontology"},{"location":"build/#2-bdrc-auth-policies","text":"Auth policies specify the valid associations between Endpoint and Auth0 Groups, Roles and Applications and valid associations between ResourceAccess, BDRC AccessTypes, and Auth0 permissions .","title":"2) BDRC Auth policies"},{"location":"concepts/","text":"High Level concepts \uf0c1 Auth0 uses two core concepts : Applications and APIs Applications can be BDRC custom applications and auth0 applications (including some auth0 extensions). Each application has a unique pair of ClientID/ClientSecret parameters, along with callbackUrl, application type, authentication method, logo, etc\u2026 Moreover, each application defines allowed grant types, available APIs endpoints and Oauth settings (mainly OIDC conformance and token signature algorithm). The list of all applications is available here . APIs \uf0c1 APIs are used (or consumed) by authorized applications. APIs have a unique id and a unique identifier (elsewhere referred to as audience). Each API specifies its signing algorithm and tokens timeout values. An example can be found here where we define the authorized applications for the auth0-authorization-extension -api. Example 1 of apps and Apis usage : Getting an Api object and a token for a specific user and application: \uf0c1 This code illustrates two ways to get a token 1) For using the Auth0 API object 2) For a client app to login to the Auth API in order to get a token: this token can then be used to interract with the Auth API Requesting a token for using the Auth API HttpClient client=HttpClientBuilder.create().build(); HttpPost post=new HttpPost(\"https://bdrc-io.auth0.com/oauth/token\"); HashMap String,String json = new HashMap (); json.put(\"grant_type\",\"client_credentials\"); json.put(\"client_id\",AuthProps.getProperty(\"lds-pdiClientID\")); json.put(\"client_secret\",AuthProps.getProperty(\"lds-pdiClientSecret\")); json.put(\"audience\",\"https://bdrc-io.auth0.com/api/v2/\"); ObjectMapper mapper=new ObjectMapper(); String post_data=mapper.writer().writeValueAsString(json); StringEntity se = new StringEntity(post_data); se.setContentType(new BasicHeader(HTTP.CONTENT_TYPE, \"application/json\")); post.setEntity(se); HttpResponse response = client.execute(post); OR (Login in a specific user using a AuthAPI object) AuthAPI auth=new AuthAPI( \"bdrc-io.auth0.com\", AuthProps.getProperty(\"lds-pdiClientID\"), AuthProps.getProperty(\"lds-pdiClientSecret\")); AuthRequest req=auth.login(\"privateuser@bdrc.com\", \"privateuser\"); req.setScope(\"openid offline_access\"); req.setAudience(\"https://bdrc-io.auth0.com/api/v2/\"); String token = req.execute().getIdToken(); Note that audience must (obviously) be the same in both requests : it determines the main API we are getting tokens from. Example 2 of apps and Apis usage (getting an Api object then ask for all the groups of users): HttpClient client=HttpClientBuilder.create().build(); HttpPost post=new HttpPost(\"https://bdrc-io.auth0.com/oauth/token\"); HashMap String,String json = new HashMap (); json.put(\"grant_type\",\"client_credentials\"); json.put(\"client_id\",AuthProps.getProperty(\"lds-pdiClientID\")); json.put(\"client_secret\",AuthProps.getProperty(\"lds-pdiClientSecret\")); json.put(\"audience\",\"urn:auth0-authz-api\"); Here, the ldspdi application is requesting a token for accessing the auth0 extension API. The audience request parameter specifies the API ldspdi wants to use. Once we get the token, we can query the API endpoint: HttpClient client=HttpClientBuilder.create().build(); HttpGet get=new HttpGet(\"https://bdrc-io.us.webtask.io/adf6e2f2b84784b57522e3b19dfc9201/api/groups\"); get.addHeader(\"Authorization\", \"Bearer \"+token);","title":"High Level concepts"},{"location":"concepts/#high-level-concepts","text":"Auth0 uses two core concepts : Applications and APIs Applications can be BDRC custom applications and auth0 applications (including some auth0 extensions). Each application has a unique pair of ClientID/ClientSecret parameters, along with callbackUrl, application type, authentication method, logo, etc\u2026 Moreover, each application defines allowed grant types, available APIs endpoints and Oauth settings (mainly OIDC conformance and token signature algorithm). The list of all applications is available here .","title":"High Level concepts"},{"location":"concepts/#apis","text":"APIs are used (or consumed) by authorized applications. APIs have a unique id and a unique identifier (elsewhere referred to as audience). Each API specifies its signing algorithm and tokens timeout values. An example can be found here where we define the authorized applications for the auth0-authorization-extension -api.","title":"APIs"},{"location":"concepts/#example-1-of-apps-and-apis-usage-getting-an-api-object-and-a-token-for-a-specific-user-and-application","text":"This code illustrates two ways to get a token 1) For using the Auth0 API object 2) For a client app to login to the Auth API in order to get a token: this token can then be used to interract with the Auth API Requesting a token for using the Auth API HttpClient client=HttpClientBuilder.create().build(); HttpPost post=new HttpPost(\"https://bdrc-io.auth0.com/oauth/token\"); HashMap String,String json = new HashMap (); json.put(\"grant_type\",\"client_credentials\"); json.put(\"client_id\",AuthProps.getProperty(\"lds-pdiClientID\")); json.put(\"client_secret\",AuthProps.getProperty(\"lds-pdiClientSecret\")); json.put(\"audience\",\"https://bdrc-io.auth0.com/api/v2/\"); ObjectMapper mapper=new ObjectMapper(); String post_data=mapper.writer().writeValueAsString(json); StringEntity se = new StringEntity(post_data); se.setContentType(new BasicHeader(HTTP.CONTENT_TYPE, \"application/json\")); post.setEntity(se); HttpResponse response = client.execute(post); OR (Login in a specific user using a AuthAPI object) AuthAPI auth=new AuthAPI( \"bdrc-io.auth0.com\", AuthProps.getProperty(\"lds-pdiClientID\"), AuthProps.getProperty(\"lds-pdiClientSecret\")); AuthRequest req=auth.login(\"privateuser@bdrc.com\", \"privateuser\"); req.setScope(\"openid offline_access\"); req.setAudience(\"https://bdrc-io.auth0.com/api/v2/\"); String token = req.execute().getIdToken(); Note that audience must (obviously) be the same in both requests : it determines the main API we are getting tokens from. Example 2 of apps and Apis usage (getting an Api object then ask for all the groups of users): HttpClient client=HttpClientBuilder.create().build(); HttpPost post=new HttpPost(\"https://bdrc-io.auth0.com/oauth/token\"); HashMap String,String json = new HashMap (); json.put(\"grant_type\",\"client_credentials\"); json.put(\"client_id\",AuthProps.getProperty(\"lds-pdiClientID\")); json.put(\"client_secret\",AuthProps.getProperty(\"lds-pdiClientSecret\")); json.put(\"audience\",\"urn:auth0-authz-api\"); Here, the ldspdi application is requesting a token for accessing the auth0 extension API. The audience request parameter specifies the API ldspdi wants to use. Once we get the token, we can query the API endpoint: HttpClient client=HttpClientBuilder.create().build(); HttpGet get=new HttpGet(\"https://bdrc-io.us.webtask.io/adf6e2f2b84784b57522e3b19dfc9201/api/groups\"); get.addHeader(\"Authorization\", \"Bearer \"+token);","title":"Example 1 of apps and Apis usage : Getting an Api object and a token for a specific user and application:"},{"location":"endpoint/","text":"","title":"Endpoint"},{"location":"extend/","text":"Auth0 model and its extension provide a solid mechanism for authentication and user profile management. On top of this, BDRC still needs to implement ways to secure endpoints and resources according to Auth0 users' profiles. BDRC therefore needs to extend the Auth0 authentication model in order to implement these two secured objects (endpoint and resource Access) and their relationships with the core Auth0 model. Endpoint: An endpoint is uniquely identified by a path and an Application resource. It can be accessed by all the users belonging to its associated Groups or having one of its associated Roles. Endpoints models are built as follows: Resource Access: A Resource Access is independent from any endpoint as it is only linked to specific permissions and BDRC Acces Types. It is used to check access to secured resources served by any endpoint or application (wether these endpoints or application are otherwise secured or not). In other words, one can have public endpoints or applications implementing specific policies for resource access.","title":"Extending Auth0 model"},{"location":"modes/","text":"Securing web services using BDRC Auth library requires to filter all incoming requests in order to instantiate an Access object , to be put in the request context for later usage within a BUDA service. Filtering basics \uf0c1 The main functions of an Auth filter are: Looking up for an Auth0 token: this token can be found either in the \"Authorization\" or the \"Cookie\" header of the request. Querying the RDF Auth Model for the requested service path in oder to determine if this path is secured or not. Instantiating an Access object to be used accross the application from the request context. granting or denying access to the requested service path ( the auth filter is therefore the actual and direct implementation of the Endpoint access control mechanism ) Filter implementation examples \uf0c1 On Ldspdi RdfAuthFilter ( here ) On BUDA IIIF Server IIIFRdfAuthFilter ( here ) On BUDA IIIF presentation server IIIFPresAuthFilter ( here ) Remark: Ldspdi is mostly using Endpoint access control features of the Auth library while both IIIF services -having public endpoints- use exclusively Resource based Access control.","title":"Auth request Filters"},{"location":"modes/#filtering-basics","text":"The main functions of an Auth filter are: Looking up for an Auth0 token: this token can be found either in the \"Authorization\" or the \"Cookie\" header of the request. Querying the RDF Auth Model for the requested service path in oder to determine if this path is secured or not. Instantiating an Access object to be used accross the application from the request context. granting or denying access to the requested service path ( the auth filter is therefore the actual and direct implementation of the Endpoint access control mechanism )","title":"Filtering basics"},{"location":"modes/#filter-implementation-examples","text":"On Ldspdi RdfAuthFilter ( here ) On BUDA IIIF Server IIIFRdfAuthFilter ( here ) On BUDA IIIF presentation server IIIFPresAuthFilter ( here ) Remark: Ldspdi is mostly using Endpoint access control features of the Auth library while both IIIF services -having public endpoints- use exclusively Resource based Access control.","title":"Filter implementation examples"},{"location":"ontData/","text":"Auth Model (ontology) \uf0c1 The BDRC-auth ontology is served here : http://purl.bdrc.io/ontology/ext/auth.ttl and can be browsed here : http://purl.bdrc.io/ontology/ext/auth/ . This ldspdi service is updated automatically each time a change occurs on any BDRC ontology, through a github webhook calling ldspdi /callbacks/github/owl-schema endpoint. Auth Data \uf0c1 Bdrc-auth library creates the triples of its RDF model : from various json responses it gets via several Auth extension API calls. from the policies.ttl file of the BDRC bdrc-auth-policies github repo. Auth data can be viewed at http://purl.bdrc.io/auth/details 1) from Auth0 platform \uf0c1 Auth0 data consist of Applications, Users, Groups, Roles and Permissions as defined and found on Auth0 platform. It is fetched from auth0 through the Auth0 Authorization Extension and produced Rdf triples like those: Application : http://purl.bdrc.io/resource-auth/WQ1WD5fRtieraybXqT9zNU342YXBIwsS a http://purl.bdrc.io/ontology/ext/auth/Application ; http://www.w3.org/2000/01/rdf-schema#label \"LDS PDI\" ; http://purl.bdrc.io/ontology/ext/auth/appType \"regular_web\" ; http://purl.bdrc.io/ontology/ext/auth/desc \"Linked Data Service - Public Data Interface\" . User http://purl.bdrc.io/resource-auth/103776618189565648628 a http://purl.bdrc.io/ontology/ext/auth/User ; http://purl.bdrc.io/ontology/ext/auth/connection \"google-oauth2\" ; http://purl.bdrc.io/ontology/ext/auth/id \"google-oauth2|103776618189565648628\" ; http://purl.bdrc.io/ontology/ext/auth/isSocial \"true\" ; http://purl.bdrc.io/ontology/ext/auth/provider \"google-oauth2\" ; http://xmlns.com/foaf/0.1/mbox \"quai.ledrurollin@gmail.com\" ; http://xmlns.com/foaf/0.1/name \"Nicolas Berger\" . Group http://purl.bdrc.io/resource-auth/f0f95a54-56cf-4bce-bf9d-8d2df6779b60 a http://purl.bdrc.io/ontology/ext/auth/Group ; http://www.w3.org/2000/01/rdf-schema#label \"admin\" ; http://purl.bdrc.io/ontology/ext/auth/desc \"admin BDRC group\" ; http://purl.bdrc.io/ontology/ext/auth/hasMember http://purl.bdrc.io/resource-auth/110316226482380068187 , http://purl.bdrc.io/resource-auth/114635926879799654981 , http://purl.bdrc.io/resource-auth/115151386535573478153 , http://purl.bdrc.io/resource-auth/5b489b9e9aa9ae06e88e4359 ; http://purl.bdrc.io/ontology/ext/auth/hasRole http://purl.bdrc.io/resource-auth/11d392f2-4cc8-4e32-aeb1-4beaf067a82d , http://purl.bdrc.io/resource-auth/72858194-17ae-449f-99d2-1d99b669dd0f , http://purl.bdrc.io/resource-auth/7edbd29c-f4cc-43aa-819c-53e4aac0d7a5 , http://purl.bdrc.io/resource-auth/d1739813-e745-4336-a9cb-a493ddac7f83 , http://purl.bdrc.io/resource-auth/f918937d-e7b0-482d-b426-42c6b8436919 . Role http://purl.bdrc.io/resource-auth/7edbd29c-f4cc-43aa-819c-53e4aac0d7a5 a http://purl.bdrc.io/ontology/ext/auth/Role ; http://www.w3.org/2000/01/rdf-schema#label \"ldsreadprivate\" ; http://purl.bdrc.io/ontology/ext/auth/appId http://purl.bdrc.io/resource-auth/WQ1WD5fRtieraybXqT9zNU342YXBIwsS ; http://purl.bdrc.io/ontology/ext/auth/appType \"client\" ; http://purl.bdrc.io/ontology/ext/auth/desc \"read private or restricted content\"; http://purl.bdrc.io/ontology/ext/auth/hasPermission http://purl.bdrc.io/resource-auth/0a5f7978-140b-4d73-90aa-61cd52f4440d , http://purl.bdrc.io/resource-auth/41b063fe-faf1-43b3-af64-7fbea2bf647f . Permission http://purl.bdrc.io/resource-auth/0a5f7978-140b-4d73-90aa-61cd52f4440d a http://purl.bdrc.io/ontology/ext/auth/Permission ; http://www.w3.org/2000/01/rdf-schema#label \"readonly\" ; http://purl.bdrc.io/ontology/ext/auth/appId http://purl.bdrc.io/resource-auth/WQ1WD5fRtieraybXqT9zNU342YXBIwsS ; http://purl.bdrc.io/ontology/ext/auth/desc \"basic read only permission\" . 2) from BDRC github repo \uf0c1 The policies.ttl is read into the overall RDF Auth model Policies are made of Endpoint and ResourceAccess rdf resources, as follows: Endpoint example: adr:Edpa3 a aut:Endpoint ; aut:path \"auth/rdf/admin\" ; aut:forGroup adr:f0f95a54-56cf-4bce-bf9d-8d2df6779b60 ; aut:appId adr:WQ1WD5fRtieraybXqT9zNU342YXBIwsS . This indicates that the endpoint \"auth/rdf/admin\" of the application having the id \"WQ1WD5fRtieraybXqT9zNU342YXBIwsS\" is only accessible by the members of the group \"adr:f0f95a54-56cf-4bce-bf9d-8d2df6779b60\" ResourceAccess example: adr:act2 a aut:ResourceAccess; aut:forPermission adr:6ffab1d6-0d53-46c4-851a-c18d033c2e19; aut:policy bdr:AccessRestrictedSealed.","title":"Auth Ontology and Data"},{"location":"ontData/#auth-model-ontology","text":"The BDRC-auth ontology is served here : http://purl.bdrc.io/ontology/ext/auth.ttl and can be browsed here : http://purl.bdrc.io/ontology/ext/auth/ . This ldspdi service is updated automatically each time a change occurs on any BDRC ontology, through a github webhook calling ldspdi /callbacks/github/owl-schema endpoint.","title":"Auth Model (ontology)"},{"location":"ontData/#auth-data","text":"Bdrc-auth library creates the triples of its RDF model : from various json responses it gets via several Auth extension API calls. from the policies.ttl file of the BDRC bdrc-auth-policies github repo. Auth data can be viewed at http://purl.bdrc.io/auth/details","title":"Auth Data"},{"location":"ontData/#1-from-auth0-platform","text":"Auth0 data consist of Applications, Users, Groups, Roles and Permissions as defined and found on Auth0 platform. It is fetched from auth0 through the Auth0 Authorization Extension and produced Rdf triples like those: Application : http://purl.bdrc.io/resource-auth/WQ1WD5fRtieraybXqT9zNU342YXBIwsS a http://purl.bdrc.io/ontology/ext/auth/Application ; http://www.w3.org/2000/01/rdf-schema#label \"LDS PDI\" ; http://purl.bdrc.io/ontology/ext/auth/appType \"regular_web\" ; http://purl.bdrc.io/ontology/ext/auth/desc \"Linked Data Service - Public Data Interface\" . User http://purl.bdrc.io/resource-auth/103776618189565648628 a http://purl.bdrc.io/ontology/ext/auth/User ; http://purl.bdrc.io/ontology/ext/auth/connection \"google-oauth2\" ; http://purl.bdrc.io/ontology/ext/auth/id \"google-oauth2|103776618189565648628\" ; http://purl.bdrc.io/ontology/ext/auth/isSocial \"true\" ; http://purl.bdrc.io/ontology/ext/auth/provider \"google-oauth2\" ; http://xmlns.com/foaf/0.1/mbox \"quai.ledrurollin@gmail.com\" ; http://xmlns.com/foaf/0.1/name \"Nicolas Berger\" . Group http://purl.bdrc.io/resource-auth/f0f95a54-56cf-4bce-bf9d-8d2df6779b60 a http://purl.bdrc.io/ontology/ext/auth/Group ; http://www.w3.org/2000/01/rdf-schema#label \"admin\" ; http://purl.bdrc.io/ontology/ext/auth/desc \"admin BDRC group\" ; http://purl.bdrc.io/ontology/ext/auth/hasMember http://purl.bdrc.io/resource-auth/110316226482380068187 , http://purl.bdrc.io/resource-auth/114635926879799654981 , http://purl.bdrc.io/resource-auth/115151386535573478153 , http://purl.bdrc.io/resource-auth/5b489b9e9aa9ae06e88e4359 ; http://purl.bdrc.io/ontology/ext/auth/hasRole http://purl.bdrc.io/resource-auth/11d392f2-4cc8-4e32-aeb1-4beaf067a82d , http://purl.bdrc.io/resource-auth/72858194-17ae-449f-99d2-1d99b669dd0f , http://purl.bdrc.io/resource-auth/7edbd29c-f4cc-43aa-819c-53e4aac0d7a5 , http://purl.bdrc.io/resource-auth/d1739813-e745-4336-a9cb-a493ddac7f83 , http://purl.bdrc.io/resource-auth/f918937d-e7b0-482d-b426-42c6b8436919 . Role http://purl.bdrc.io/resource-auth/7edbd29c-f4cc-43aa-819c-53e4aac0d7a5 a http://purl.bdrc.io/ontology/ext/auth/Role ; http://www.w3.org/2000/01/rdf-schema#label \"ldsreadprivate\" ; http://purl.bdrc.io/ontology/ext/auth/appId http://purl.bdrc.io/resource-auth/WQ1WD5fRtieraybXqT9zNU342YXBIwsS ; http://purl.bdrc.io/ontology/ext/auth/appType \"client\" ; http://purl.bdrc.io/ontology/ext/auth/desc \"read private or restricted content\"; http://purl.bdrc.io/ontology/ext/auth/hasPermission http://purl.bdrc.io/resource-auth/0a5f7978-140b-4d73-90aa-61cd52f4440d , http://purl.bdrc.io/resource-auth/41b063fe-faf1-43b3-af64-7fbea2bf647f . Permission http://purl.bdrc.io/resource-auth/0a5f7978-140b-4d73-90aa-61cd52f4440d a http://purl.bdrc.io/ontology/ext/auth/Permission ; http://www.w3.org/2000/01/rdf-schema#label \"readonly\" ; http://purl.bdrc.io/ontology/ext/auth/appId http://purl.bdrc.io/resource-auth/WQ1WD5fRtieraybXqT9zNU342YXBIwsS ; http://purl.bdrc.io/ontology/ext/auth/desc \"basic read only permission\" .","title":"1) from Auth0 platform"},{"location":"ontData/#2-from-bdrc-github-repo","text":"The policies.ttl is read into the overall RDF Auth model Policies are made of Endpoint and ResourceAccess rdf resources, as follows: Endpoint example: adr:Edpa3 a aut:Endpoint ; aut:path \"auth/rdf/admin\" ; aut:forGroup adr:f0f95a54-56cf-4bce-bf9d-8d2df6779b60 ; aut:appId adr:WQ1WD5fRtieraybXqT9zNU342YXBIwsS . This indicates that the endpoint \"auth/rdf/admin\" of the application having the id \"WQ1WD5fRtieraybXqT9zNU342YXBIwsS\" is only accessible by the members of the group \"adr:f0f95a54-56cf-4bce-bf9d-8d2df6779b60\" ResourceAccess example: adr:act2 a aut:ResourceAccess; aut:forPermission adr:6ffab1d6-0d53-46c4-851a-c18d033c2e19; aut:policy bdr:AccessRestrictedSealed.","title":"2) from BDRC github repo"},{"location":"resAccess/","text":"Once the request is validated against BDRC auth policies, there is still the possibility of having the accessed endpoint (wether it is secured or not) delivering resources whose access types are limited. Therefore, we have a second security level inside the service offered by a given endpoint. Here, we will have to check BDRC policies to determine if the user profile is compliant or not with the requested resource access type. Basic usage \uf0c1 A basic usage of this auth feature consist of calling the hasResourceAcess(String accessType) of the Access object made available in the request context by the Auth filter. Extended usage \uf0c1 BDRC auth library feature can also be associated with other security mechanisms, not depending upon user profile. For instance, BDRC restricts access to some resources on the basis of the geo location of the requester. This kind of implementation uses a \"wrapper\" that extend the basic \"Access\" object provided by the BDRC Auth library, by adding to it geo location services. A good example of such a \"wrapper\" can be found here: ResourceAccessValidation where the geo location based access restriction is implemented as follows: public boolean isAccessible(HttpServletRequest request) { if (access == null) { access = new Access(); } boolean accessible = true; if (accessType.equals(RdfConstants.RESTRICTED_CHINA)) { if (CHINA.equalsIgnoreCase(GeoLocation.getCountryName(request.getRemoteAddr()))) { // if Geolocation country name is null (i.e throws -for instance- an IP parsing // exception) // then access is denied accessible = false; } } return (accessible access.hasResourceAccess(accessType) || fairUse); }","title":"Resource access control"},{"location":"resAccess/#basic-usage","text":"A basic usage of this auth feature consist of calling the hasResourceAcess(String accessType) of the Access object made available in the request context by the Auth filter.","title":"Basic usage"},{"location":"resAccess/#extended-usage","text":"BDRC auth library feature can also be associated with other security mechanisms, not depending upon user profile. For instance, BDRC restricts access to some resources on the basis of the geo location of the requester. This kind of implementation uses a \"wrapper\" that extend the basic \"Access\" object provided by the BDRC Auth library, by adding to it geo location services. A good example of such a \"wrapper\" can be found here: ResourceAccessValidation where the geo location based access restriction is implemented as follows: public boolean isAccessible(HttpServletRequest request) { if (access == null) { access = new Access(); } boolean accessible = true; if (accessType.equals(RdfConstants.RESTRICTED_CHINA)) { if (CHINA.equalsIgnoreCase(GeoLocation.getCountryName(request.getRemoteAddr()))) { // if Geolocation country name is null (i.e throws -for instance- an IP parsing // exception) // then access is denied accessible = false; } } return (accessible access.hasResourceAccess(accessType) || fairUse); }","title":"Extended usage"}]}